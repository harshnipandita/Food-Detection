# -*- coding: utf-8 -*-
"""Mini Resnet50.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tCd2G7HcbFbz2ZbSMmbYqRTxi1At1WjK

# Download and extract Food 101 dataset
"""

# Commented out IPython magic to ensure Python compatibility.
# For image processing, visualizing images and plotting graphs
import cv2
import os
import random
import collections
from collections import defaultdict

from shutil import copy
from shutil import copytree, rmtree
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as img
# %matplotlib inline

# Check TF version and whether GPU is enabled
import tensorflow as tf
print(tf.__version__)
print(tf.test.gpu_device_name())

'''Expected output:
2.2.0
/device:GPU:0'''

# Helper function to download and extract data and extract

def get_data():
  if "food-101" in os.listdir():
    print("Dataset already exists")
  else:
    tf.keras.utils.get_file(
    'food-101.tar.gz',
    'http://data.vision.ee.ethz.ch/cvl/food-101.tar.gz',
    cache_subdir='/content',
    extract=True,
    archive_format='tar',
    cache_dir=None
    )
    print("Dataset downloaded and extracted successfully!")

# Call the helper function
get_data()

"""# Analysing data and visualizing images"""

#Lets have a look into the directory
os.listdir('food-101/')

"""This dataset has 101 different classes of food with 1000 images for each class.
This 1000 images are divided into 750 training samples and 250 test samples

Next we list all the classes/labels of the dataset
"""

#List of all classes
foods_sorted = sorted(os.listdir('food-101/images'))
foods_sorted

#The meta file contains labels for train and test in txt format as well 101 classes
os.listdir('food-101/meta')

"""Now let's visualize a randomly selected image from every class"""

# Visualize the data, showing one image per class from 101 classes
rows = 17
cols = 6
fig, ax = plt.subplots(rows, cols, figsize=(50,50))
fig.suptitle("Showing one random image from each class", y=1.05, fontsize=60)
data_dir = "food-101/images/"
foods_sorted = sorted(os.listdir(data_dir))
food_id = 0
for i in range(rows):
  for j in range(cols):
    try:
      food_selected = foods_sorted[food_id]
      food_id += 1
    except:
      break
    food_selected_images = os.listdir(os.path.join(data_dir,food_selected)) # returns the list of all files present in each food category
    food_selected_random = np.random.choice(food_selected_images) # picks one food item from the list as choice, takes a list and returns one random item
    img = plt.imread(os.path.join(data_dir,food_selected, food_selected_random))
    ax[i][j].imshow(img)
    ax[i][j].set_title(food_selected, pad = 20,fontsize=40)

plt.setp(ax, xticks=[],yticks=[])
plt.tight_layout()

"""#Splitting the data into train and test set"""

# Helper method to split dataset into train and test folders
from shutil import copy
def prepare_data(filepath, src, dest):
  classes_images = defaultdict(list)
  with open(filepath, 'r') as txt:
      paths = [read.strip() for read in txt.readlines()]
      for p in paths:
        food = p.split('/')
        classes_images[food[0]].append(food[1] + '.jpg')

  for food in classes_images.keys():
    print("\nCopying images into ",food)
    if not os.path.exists(os.path.join(dest,food)):
      os.makedirs(os.path.join(dest,food))
    for i in classes_images[food]:
      copy(os.path.join(src,food,i), os.path.join(dest,food,i))
  print("Copying Done!")

# Prepare train dataset by copying images from food-101/images to food-101/train using the file train.txt
print("Creating train data...")
prepare_data('food-101/meta/train.txt', 'food-101/images', 'food-101/train')

# Prepare test data by copying images from food-101/images to food-101/test using the file test.txt
print("Creating test data...")
prepare_data('food-101/meta/test.txt', 'food-101/images', 'food-101/test')

"""Now we have splitted the data into train and test dataset"""

# Helper method to create train_mini and test_mini data samples
from shutil import copytree, rmtree
def dataset_mini(food_list, src, dest):
  if not os.path.exists(dest):
    os.makedirs(dest)   #Make a directory if it does not exists
  for food_item in food_list :
    print("Copying images into",food_item)
    copytree(os.path.join(src,food_item), os.path.join(dest,food_item))

# picking 11 random food items and generating separate data folders for the same
food_list = ['ramen','ravioli','red_velvet_cake','risotto','oysters','pad_thai','paella','pancakes','panna_cotta','peking_duck','pho']  #You can choose any food items
src_train = 'food-101/train'
dest_train = 'food-101/train_mini'
src_test = 'food-101/test'
dest_test = 'food-101/test_mini'

#Create subset for training data
print("Creating train data folder with new classes")
dataset_mini(food_list, src_train, dest_train)

#Create subset for test data
print("Creating test data folder with new classes")
dataset_mini(food_list, src_test, dest_test)

# Declare some variables
n_classes = 11   #num of output classes
img_width, img_height = 299, 299   #Default image size
train_data_dir = 'food-101/train_mini'
validation_data_dir = 'food-101/test_mini'
batch_size = 16

from __future__ import absolute_import, division, print_function

#Necessay tensorflow imports
import tensorflow as tf

import tensorflow.keras.backend as K
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
from tensorflow.keras import regularizers
from tensorflow.keras.applications.inception_v3 import InceptionV3
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.layers import GlobalAveragePooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import ModelCheckpoint, CSVLogger
from tensorflow.keras.optimizers import SGD, RMSprop
from tensorflow.keras.regularizers import l2
from tensorflow.keras import callbacks
from tensorflow.keras.callbacks import TensorBoard, ReduceLROnPlateau, EarlyStopping


from tensorflow import keras
from tensorflow.keras import models
from tensorflow.keras.applications.inception_v3 import preprocess_input

"""##Testing ResNet 50 Model"""

#Input size for ResNet 50 has to be (224, 224, 3)
img_width, img_height = 224, 224

# Perform data augmentation using Image data generator
train_datagen = ImageDataGenerator(
    rescale=1. / 255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True)

test_datagen = ImageDataGenerator(rescale=1. / 255)

train_generator = train_datagen.flow_from_directory(train_data_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical')

validation_generator = test_datagen.flow_from_directory(
    validation_data_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical')

from tensorflow.keras.applications.resnet50 import ResNet50

resnet50 = ResNet50(weights='imagenet', include_top=False)
x = resnet50.output
x = GlobalAveragePooling2D()(x)
x = Dense(128,activation='relu')(x)
x = Dropout(0.2)(x)   #Dropout to prvenet overfitting


                              #L2 regularization to prevent overfitting
predictions = Dense(n_classes ,kernel_regularizer=regularizers.l2(0.005), activation='softmax')(x)

model = Model(inputs=resnet50.input, outputs=predictions)

#Compile the model        #Learning rate = 0.001
model.compile(optimizer=SGD(lr=0.001, momentum=0.9), loss='categorical_crossentropy', metrics=['accuracy'])



history_resnet50 = model.fit_generator(train_generator,
                    validation_data=validation_generator,
                    epochs=10,
                    verbose=1)

"""#Plotting the results of model"""

import matplotlib.pyplot as plt
#Function to plot Accuracy
def plot_accuracy(title):
    plt.title(title)
    plt.plot(history_resnet50.history['val_accuracy'])
    plt.ylabel('Validation accuracy')
    plt.xlabel('epoch')
    plt.legend(['ResNet50'], loc='best')
    plt.show()

#Function to plot Loss
def plot_loss(title):
    plt.title(title)
    plt.plot(history_resnet50.history['val_loss'])
    plt.ylabel('Validation Loss')
    plt.xlabel('epoch')
    plt.legend(['ResNet50'], loc='best')
    plt.show()


plot_accuracy('Accuracy')
plot_loss('Loss')

"""##Having a closer look on accuracy and loss"""

plt.plot(history_resnet50.history['val_accuracy'][4:])
plt.ylabel('Validation accuracy')
plt.xlabel('epoch')
plt.legend(['ResNet50'], loc='best')
plt.show()

plt.plot(history_resnet50.history['val_loss'][4:])
plt.ylabel('Validation accuracy')
plt.xlabel('epoch')
plt.legend(['ResNet50'], loc='best')
plt.show()

